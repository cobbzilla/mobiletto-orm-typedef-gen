{{#if disclaimer}}// {{{ disclaimer }}}{{#if header}}
{{{header}}}{{/if}}{{/if}}

import { type Ref } from "vue";
import type { MobilettoOrmObject, MobilettoOrmValidationErrors } from "mobiletto-orm-typedef";
import { errMatch, errMatchStart, normalizeMsg, fieldErrorMessage } from "hokey-runtime";

export type ActionConfig = {
    path?: string;
    func?: (obj: MobilettoOrmObject, successSnackbar: Ref<string>, errorSnackbar: Ref<string>) => unknown;
    message: string;
    icon?: string;
    when?: (obj: MobilettoOrmObject) => boolean;
};

export const typeDefFieldErrorMessage = (
    field: string | string[],
    messages: Record<string, string>,
    labelPrefixes: string[],
    clientErrors: MobilettoOrmValidationErrors,
    serverErrors: MobilettoOrmValidationErrors,
    submitted?: boolean,
    objPath?: string,
): string => {
    if (submitted === false) {
        return "";
    }
    const fields = Array.isArray(field) ? field : [field];
    const fieldName = fields[0];
    for (const f of fields) {
        const clientErrFields = Object.keys(clientErrors);
        const serverErrFields = Object.keys(serverErrors);
        let errMsg = clientErrFields.find(errMatch(f));
        if (errMsg) {
            errMsg = errMsg + "_" + clientErrors[errMsg][0];
        } else {
            errMsg = serverErrFields.find(errMatch(f)) || undefined;
            if (errMsg) {
                errMsg = errMsg + "_" + serverErrors[errMsg][0];
            }
        }
        if (!errMsg && objPath && objPath.length > 0) {
            errMsg = clientErrFields.find(errMatchStart(objPath));
            if (errMsg) {
                errMsg = errMsg + "_" + clientErrors[errMsg][0];
            } else {
                errMsg = serverErrFields.find(errMatchStart(objPath));
                if (errMsg) {
                    errMsg = errMsg + "_" + serverErrors[errMsg][0];
                }
            }
        }
        if (errMsg) {
            errMsg = normalizeMsg(errMsg);
            const labelPfx = labelPrefixes.includes("") ? labelPrefixes : [...labelPrefixes, ""];
            const fld = normalizeMsg(fieldName);
            return fieldErrorMessage(fld, errMsg, messages, labelPfx);
        }
    }
    return "";
};

export type ObjectNav = {
    append?: boolean;
    next: string | number;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const deepUpdate = (obj: any, fieldPath: string, value: any) => {
    const parts = fieldPath.split(".");
    const operations = [];
    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        let squareBracketStart = part.indexOf("[");
        if (squareBracketStart !== -1) {
            const field = part.substring(0, squareBracketStart);
            operations.push({ next: field });
            while (squareBracketStart !== -1) {
                const squareBracketEnd = part.indexOf("]", squareBracketStart);
                if (squareBracketEnd === -1) {
                    throw new Error(
                        `deepUpdate: invalid fieldPath (missing closing square bracket): ${fieldPath}`,
                    );
                }
                const index = part.substring(squareBracketStart + 1, squareBracketEnd);
                if (index.length === 0) {
                    operations.push({ append: true });
                    if (part.includes("[", squareBracketEnd)) {
                        throw new Error(
                            `deepUpdate: invalid fieldPath (cannot update after append []): ${fieldPath}`,
                        );
                    }
                    break;
                } else {
                    operations.push({ next: parseInt(index) });
                }
                squareBracketStart = part.indexOf("[", squareBracketEnd);
            }
        } else {
            operations.push({ next: part });
        }
    }

    let thing = obj;
    for (let i = 0; i < operations.length - 1; i++) {
        const op = operations[i];
        const next = op.next;
        if (typeof next === "string" || typeof next === "number") {
            thing = thing[next];
        }
    }

    const lastOp = operations[operations.length - 1];
    if (lastOp.append) {
        thing.push(value);
    } else {
        thing[lastOp.next!] = value;
    }
};
