import { MobilettoOrmError, MobilettoOrmTypeDef, MobilettoOrmValidationError, } from "mobiletto-orm-typedef";
import * as fs from "fs";
import Handlebars from "handlebars";
import { dirname } from "path";
import { fileURLToPath } from "url";
const __dirname = dirname(fileURLToPath(import.meta.url));
export const STANDARD_AUTOGEN_FILE_DISCLAIMER = "DO NOT EDIT THIS FILE. AUTO-GENERATED BY mobiletto-orm-typedef-gen";
const findDecls = (name, fields) => {
    return _findDecls(name, fields, []);
};
const _findDecls = (name, fields, decls) => {
    for (const fieldName of Object.keys(fields)) {
        const field = fields[fieldName];
        if (field.type === "object" && field.fields) {
            const subName = name + "_" + field.name;
            const subFields = field.fields;
            decls.unshift({ name: subName, fields: subFields });
            _findDecls(subName, subFields, decls);
        }
    }
    return decls;
};
const defaultPrepareContext = (typeDef, ctx) => {
    for (const fieldName of Object.keys(ctx.fields)) {
        const field = ctx.fields[fieldName];
        field.optional = !field.required || field.when;
        field.typeIsBoolean = field.type === "boolean";
        field.typeIsString = field.type === "string";
        field.typeIsNumber = field.type === "number";
        field.typeIsArray = field.type === "array";
        field.typeIsObject = field.type === "object";
        if (field.typeIsArray) {
            field.valueType =
                field.values && Array.isArray(field.values) && field.values.length > 0
                    ? typeof field.values[0]
                    : field.items &&
                        Array.isArray(field.items) &&
                        field.items.length > 0 &&
                        typeof field.items[0] === "object" &&
                        field.items[0].value
                        ? typeof field.items[0].value
                        : null;
            if (field.valueType == null) {
                const errors = {};
                errors[field.name] = ["indeterminateArrayValueType"];
                throw new MobilettoOrmValidationError(errors);
            }
        }
    }
    ctx.typeName = typeDef.typeName;
    ctx.curlyOpen = "{";
    ctx.curlyClose = "}";
    return ctx;
};
export const generate = (typeDef, templatePath, opts) => {
    if (!(typeDef instanceof MobilettoOrmTypeDef)) {
        typeDef = new MobilettoOrmTypeDef(typeDef);
    }
    const disclaimer = (opts === null || opts === void 0 ? void 0 : opts.disclaimer) ? opts.disclaimer : STANDARD_AUTOGEN_FILE_DISCLAIMER;
    const name = (opts === null || opts === void 0 ? void 0 : opts.name) ? opts.name : typeDef.typeName;
    const decls = [...findDecls(name, typeDef.fields), { name, fields: typeDef.fields, root: true }];
    let allData = "";
    let first = true;
    while (decls.length > 0) {
        const decl = decls.pop();
        if (!decl)
            break;
        const typeContext = defaultPrepareContext(typeDef, {
            typeDef,
            name: decl.name,
            fields: decl.fields,
            disclaimer: decls.length > 0 ? null : disclaimer,
            first,
            root: decl.root || false,
        });
        const preparedContext = (opts === null || opts === void 0 ? void 0 : opts.prepareContext) ? opts.prepareContext(typeDef, typeContext) : typeContext;
        first = false;
        typeContext.ctx = typeContext;
        // sanity, scrub templatePath; we should only every read template files
        const lastSlash = templatePath.lastIndexOf("/");
        if (lastSlash === -1 || lastSlash === templatePath.length - 1) {
            throw new MobilettoOrmError(`invalid template path: ${templatePath}`);
        }
        const endPath = templatePath.substring(0, lastSlash).replace(/^[A-Z0-9/_-]/g, "") + templatePath.substring(lastSlash);
        if (endPath !== templatePath) {
            throw new MobilettoOrmError(`invalid template path: ${templatePath}`);
        }
        if (!templatePath.endsWith(".ts.hbs")) {
            throw new MobilettoOrmError(`invalid template path: ${templatePath}`);
        }
        const template = fs.readFileSync(__dirname + "/" + templatePath).toString("utf8");
        const data = Handlebars.compile(template)(preparedContext);
        allData = data + allData;
    }
    if (opts === null || opts === void 0 ? void 0 : opts.outfile) {
        fs.writeFileSync(opts.outfile, allData);
    }
    return allData;
};
